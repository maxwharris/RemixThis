// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                         String   @id @default(cuid())
  username                   String   @unique
  email                      String   @unique
  passwordHash               String   @map("password_hash")
  emailVerified              Boolean  @default(false) @map("email_verified")
  emailVerificationToken     String?  @map("email_verification_token")
  emailVerificationExpires   DateTime? @map("email_verification_expires")
  profilePhoto               String?  @map("profile_photo")
  description                String?
  createdAt                  DateTime @default(now()) @map("created_at")
  updatedAt                  DateTime @updatedAt @map("updated_at")

  // Relations
  posts                      Post[]
  votes                      Vote[]
  comments                   Comment[]
  commentVotes               CommentVote[]
  remixes                    Remix[]
  notifications              Notification[] @relation("NotificationUser")
  sentNotifications          Notification[] @relation("NotificationFromUser")
  queueItems                 UserQueue[]
  queueSettings              UserQueueSettings?
  playlists                  Playlist[]

  @@map("users")
}

model Post {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  title       String
  description String?
  filePath    String?  @map("file_path")
  youtubeUrl  String?  @map("youtube_url")
  postType    String   @map("post_type")
  coverArt    String?  @map("coverArt")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  postTags        PostTag[]
  votes           Vote[]
  comments        Comment[]
  originalRemixes Remix[]         @relation("OriginalPost")
  remixPosts      Remix[]         @relation("RemixPost")
  notifications   Notification[]
  queueItems      UserQueue[]
  playlistTracks  PlaylistTrack[]

  @@map("posts")
}

model Tag {
  id    String @id @default(cuid())
  name  String @unique

  // Relations
  postTags PostTag[]

  @@map("tags")
}

model PostTag {
  postId String @map("post_id")
  tagId  String @map("tag_id")

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@map("post_tags")
}

model Remix {
  id             String   @id @default(cuid())
  originalPostId String   @map("original_post_id")
  remixPostId    String   @map("remix_post_id")
  userId         String   @map("user_id")
  createdAt      DateTime @default(now()) @map("created_at")

  // Relations
  originalPost Post @relation("OriginalPost", fields: [originalPostId], references: [id], onDelete: Cascade)
  remixPost    Post @relation("RemixPost", fields: [remixPostId], references: [id], onDelete: Cascade)
  user         User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("remixes")
}

model Vote {
  id       String   @id @default(cuid())
  userId   String   @map("user_id")
  postId   String   @map("post_id")
  voteType String   @map("vote_type")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("votes")
}

model Comment {
  id              String   @id @default(cuid())
  userId          String   @map("user_id")
  postId          String   @map("post_id")
  parentCommentId String?  @map("parent_comment_id")
  content         String
  filePath        String?  @map("file_path")
  isRemix         Boolean  @default(false) @map("is_remix")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  post            Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  parentComment   Comment?      @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies         Comment[]     @relation("CommentReplies")
  votes           CommentVote[]
  notifications   Notification[]

  @@map("comments")
}

model CommentVote {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  commentId String   @map("comment_id")
  voteType  String   @map("vote_type")
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@map("comment_votes")
}

model Notification {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  type       String
  title      String
  message    String
  postId     String?  @map("post_id")
  commentId  String?  @map("comment_id")
  fromUserId String   @map("from_user_id")
  isRead     Boolean  @default(false) @map("is_read")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  user     User     @relation("NotificationUser", fields: [userId], references: [id], onDelete: Cascade)
  fromUser User     @relation("NotificationFromUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  post     Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment  Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model UserQueue {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")
  position  Int      // Order in queue
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@unique([userId, postId]) // Prevent duplicates
  @@index([userId, position]) // Optimize queue ordering
  @@map("user_queue")
}

model UserQueueSettings {
  id         String  @id @default(cuid())
  userId     String  @unique @map("user_id")
  shuffleMode Boolean @default(false) @map("shuffle_mode")
  repeatMode String  @default("off") @map("repeat_mode") // "off", "one", "all"
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_queue_settings")
}

model Playlist {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  name        String
  description String?
  isPublic    Boolean  @default(false) @map("is_public")
  coverImage  String?  @map("cover_image")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  tracks PlaylistTrack[]

  @@map("playlists")
}

model PlaylistTrack {
  id         String   @id @default(cuid())
  playlistId String   @map("playlist_id")
  postId     String   @map("post_id")
  position   Int      // Order in playlist
  addedAt    DateTime @default(now()) @map("added_at")

  // Relations
  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  post     Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([playlistId, postId]) // Prevent duplicates
  @@index([playlistId, position]) // Optimize playlist ordering
  @@map("playlist_tracks")
}
